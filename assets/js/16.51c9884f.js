(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{283:function(e,r,s){"use strict";s.r(r);var i=s(0),_=Object(i.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"promise的几个关键问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise的几个关键问题"}},[e._v("#")]),e._v(" Promise的几个关键问题")]),e._v(" "),s("h4",{attrs:{id:"_1-如何改变promise的状态？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何改变promise的状态？"}},[e._v("#")]),e._v(" 1. 如何改变Promise的状态？")]),e._v(" "),s("p",[e._v("如果当前状态是pending")]),e._v(" "),s("ul",[s("li",[e._v("resolve(value)：变为resolved")]),e._v(" "),s("li",[e._v("reject(reason)：变为rejected")]),e._v(" "),s("li",[e._v("抛出异常：变为rejected")])]),e._v(" "),s("h4",{attrs:{id:"_2-一个promise指定多个成功-失败回调函数，都会调用吗？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-一个promise指定多个成功-失败回调函数，都会调用吗？"}},[e._v("#")]),e._v(" 2. 一个Promise指定多个成功/失败回调函数，都会调用吗？")]),e._v(" "),s("p",[e._v("当 promise 改变为对应状态时都会顺序先后调用")]),e._v(" "),s("h4",{attrs:{id:"_3-改变promise状态和指定回调函数谁先谁后？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-改变promise状态和指定回调函数谁先谁后？"}},[e._v("#")]),e._v(" 3. 改变Promise状态和指定回调函数谁先谁后？")]),e._v(" "),s("ol",[s("li",[s("p",[s("strong",[e._v("都有可能")]),e._v(", 正常情况(异步)下是先指定回调再改变状态, 但也可以先改状态再指定回调")])]),e._v(" "),s("li",[s("p",[e._v("如何先改状态再指定回调?")]),e._v(" "),s("ol",[s("li",[e._v("在执行器中直接调用 resolve() / reject()")]),e._v(" "),s("li",[e._v("延迟更长时间才调用 then()")])])]),e._v(" "),s("li",[s("p",[e._v("什么时候才能得到数据?")]),e._v(" "),s("ol",[s("li",[e._v("如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据")]),e._v(" "),s("li",[e._v("如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据")])])])]),e._v(" "),s("h4",{attrs:{id:"_4-promise-then-返回的新promise的结果状态如何确定？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-promise-then-返回的新promise的结果状态如何确定？"}},[e._v("#")]),e._v(" 4. promise.then()返回的新promise的结果状态如何确定？")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("简单表达:由then()指定的回调函数执行的结果决定")])]),e._v(" "),s("li",[s("p",[e._v("详细表达:")]),e._v(" "),s("ol",[s("li",[e._v("如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常")]),e._v(" "),s("li",[e._v("如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值")]),e._v(" "),s("li",[e._v("如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果")])])])]),e._v(" "),s("h4",{attrs:{id:"_5-promise如何串联多个操作任务？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise如何串联多个操作任务？"}},[e._v("#")]),e._v(" 5. Promise如何串联多个操作任务？")]),e._v(" "),s("ol",[s("li",[e._v("promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用")]),e._v(" "),s("li",[e._v("通过then的链式调用串连多个同步/异步任务")])]),e._v(" "),s("h4",{attrs:{id:"_6-promiss异常穿透？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-promiss异常穿透？"}},[e._v("#")]),e._v(" 6. Promiss异常穿透？")]),e._v(" "),s("ol",[s("li",[e._v("当使用promise的then链式调用时,可以在最后指定失败的回调")]),e._v(" "),s("li",[e._v("前面任何操作出了异常, 都会传到最后失败的回调中处理")])]),e._v(" "),s("h4",{attrs:{id:"_7-如何中断promise链？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何中断promise链？"}},[e._v("#")]),e._v(" 7. 如何中断promise链？")]),e._v(" "),s("ol",[s("li",[e._v("当使用promise的then链式调用时,在中间中断,不再调用后面的回调函数")]),e._v(" "),s("li",[e._v("办法:在回调函数中返回一个pendding状态的promise对象")])])])}),[],!1,null,null,null);r.default=_.exports}}]);